<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>ands.ds.RBT API documentation</title>
    <meta name="description" content="Author: Nelson Brochado

Creation: July, 2015

Last update: 13/02/16

Contains the class RBT for rep..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#ands.ds.RBT.RBT">RBT</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ands.ds.RBT.RBT.__init__">__init__</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.clear">clear</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.contains">contains</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.delete">delete</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.height">height</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.in_order_traversal">in_order_traversal</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.insert">insert</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.insert_many">insert_many</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.is_empty">is_empty</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.is_root">is_root</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.left_rotate">left_rotate</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.maximum">maximum</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.minimum">minimum</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.post_order_traversal">post_order_traversal</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.pre_order_traversal">pre_order_traversal</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.predecessor">predecessor</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.rank">rank</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.remove_max">remove_max</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.remove_min">remove_min</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.reverse_in_order_traversal">reverse_in_order_traversal</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.right_rotate">right_rotate</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.search">search</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.search_i">search_i</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.search_r">search_r</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.show">show</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.size">size</a></li>
    <li class="mono"><a href="#ands.ds.RBT.RBT.successor">successor</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">ands.ds.RBT</span> module</h1>
  <p>Author: Nelson Brochado</p>
<p>Creation: July, 2015</p>
<p>Last update: 13/02/16</p>
<p>Contains the class RBT for representing red-black trees.</p>
<h2>Red-black tree property</h2>
<ol>
<li>
<p>Every node is either red or black.</p>
</li>
<li>
<p>The root is black.</p>
</li>
<li>
<p>Every NIL or leaf node is black.</p>
</li>
<li>
<p>If a node is red, then both its children are black,
in other words, there cannot be two red nodes in a row.</p>
</li>
<li>
<p>For every node x, each path from x to its descendent leaves
has the same number of black nodes, i.e. bh(x).</p>
</li>
</ol>
<h2>Lemma</h2>
<p>The height <code>h(x)</code> of a red-black tree with <code>n = size(x)</code> internal nodes
is at most 2 * log<sub>2</sub>(n + 1), that is, h(x) &lt;= 2 * log<sub>2</sub>(n + 1),
which is equivalent to h(x)/2 &lt;= log<sub>2</sub>(n + 1), which is equivalent to
n &gt;= 2<sup>h(x)/2</sup> - 1. If you don't understand exactly why this last statements
are equivalent, then do the reversed reasoning:</p>
<ul>
<li>
<p>n &gt;= 2<sup>h(x)/2</sup> - 1</p>
</li>
<li>
<p>n + 1 &gt;= 2<sup>h(x)/2</sup></p>
</li>
</ul>
<p>Now we log both parts</p>
<ul>
<li>
<p>log<sub>2</sub>(n + 1) &gt;= log<sub>2</sub>(2<sup>h(x)/2</sup>)</p>
</li>
<li>
<p>log<sub>2</sub>(n + 1) &gt;= h(x)/2 * log<sub>2</sub>(2)</p>
</li>
<li>
<p>log<sub>2</sub>(n + 1) &gt;= h(x)/2 * 1</p>
</li>
<li>
<p>2 * log<sub>2</sub>(n + 1) &gt;= h(x)</p>
</li>
</ul>
<h3>Proof</h3>
<ol>
<li>
<p>Prove that for all <code>x</code>, size(x) &gt;= 2<sup>bh(x)</sup> - 1 by induction.</p>
<p>1.1. <strong>Base case</strong>: <code>x</code> is a leaf, so <code>size(x) = 0</code> and <code>bh(x) = 0</code>.</p>
<p>1.2. <strong>Induction step</strong>: consider y<sub>1</sub>, y<sub>2</sub>,
and <code>x</code> such that y<sub>1</sub>.parent = y<sub>2</sub>.parent = x,
and assume (induction) that size(y<sub>1</sub>) &gt;= 2<sup>bh(y<sub>1</sub>)</sup> - 1
and size(y<sub>2</sub>) &gt;= 2<sup>bh(y<sub>2</sub>)</sup> - 1.
Prove that size(x) &gt;= 2<sup>bh(x)</sup> - 1.</p>
<p><strong>Proof</strong>:</p>
<p>size(x) = size(y<sub>1</sub>) + size(y<sub>2</sub>) + 1 &gt;= (2<sup>bh(y<sub>1</sub>)</sup> - 1)
+ (2<sup>bh(y<sub>2</sub>)</sup> - 1) + 1</p>
<p>Since bh(x) = {</p>
<pre><code>bh(y), if color(y) = red

bh(y) + 1, if color(y) = black
</code></pre>
<p>}</p>
<p>size(x) &gt;= (2<sup>bh(x) - 1</sup> - 1) + (2<sup>bh(x) - 1</sup> - 1) + 1
= (2<sup>bh(x)</sup> - 1).</p>
<p>Since every red node has black children,
in every path from <code>x</code> to a leaf node,
at least half the nodes are black, thus bh(x) &gt;= h(x)/2.
So, n = size(x) &gt;= 2<sup>h(x)/2</sup> - 1. Therefore
h(x) &lt;= 2 * log<sub>2</sub>(n + 1).</p>
<p>A red-black tree works as a binary-search tree for search,
insert, etc, so the complexity of those operations is T(n) = O(h),
that is T(n) = O(log<sub>2</sub> n), which is also the worst case complexity.</p>
</li>
</ol>
<h2>TODO</h2>
<ul>
<li>Override needed methods inherited from BST.</li>
</ul>
<h2>References</h2>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-black tree</a></p>
</li>
<li>
<p>Slides by prof. A. Carzaniga</p>
</li>
<li>
<p>Chapter 13 of <em>Introduction to Algorithms</em> (3rd ed.) by CLRS</p>
</li>
</ul>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT" class="source">
    <pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Author: Nelson Brochado

Creation: July, 2015

Last update: 13/02/16

Contains the class RBT for representing red-black trees.

## Red-black tree property

1. Every node is either red or black.

2. The root is black.

3. Every NIL or leaf node is black.

4. If a node is red, then both its children are black,
in other words, there cannot be two red nodes in a row.

5. For every node x, each path from x to its descendent leaves
has the same number of black nodes, i.e. bh(x).

## Lemma

The height `h(x)` of a red-black tree with `n = size(x)` internal nodes
is at most 2 * log<sub>2</sub>(n + 1), that is, h(x) <= 2 * log<sub>2</sub>(n + 1),
which is equivalent to h(x)/2 <= log<sub>2</sub>(n + 1), which is equivalent to
n >= 2<sup>h(x)/2</sup> - 1. If you don't understand exactly why this last statements
are equivalent, then do the reversed reasoning:

* n >= 2<sup>h(x)/2</sup> - 1

* n + 1 >= 2<sup>h(x)/2</sup>

Now we log both parts

* log<sub>2</sub>(n + 1) >= log<sub>2</sub>(2<sup>h(x)/2</sup>)

* log<sub>2</sub>(n + 1) >= h(x)/2 * log<sub>2</sub>(2)

* log<sub>2</sub>(n + 1) >= h(x)/2 * 1

* 2 * log<sub>2</sub>(n + 1) >= h(x)


### Proof

1. Prove that for all `x`, size(x) >= 2<sup>bh(x)</sup> - 1 by induction.

    1.1. **Base case**: `x` is a leaf, so `size(x) = 0` and `bh(x) = 0`.

    1.2. **Induction step**: consider y<sub>1</sub>, y<sub>2</sub>,
    and `x` such that y<sub>1</sub>.parent = y<sub>2</sub>.parent = x,
    and assume (induction) that size(y<sub>1</sub>) >= 2<sup>bh(y<sub>1</sub>)</sup> - 1
    and size(y<sub>2</sub>) >= 2<sup>bh(y<sub>2</sub>)</sup> - 1.
    Prove that size(x) >= 2<sup>bh(x)</sup> - 1.

    **Proof**:

    size(x) = size(y<sub>1</sub>) + size(y<sub>2</sub>) + 1 >= (2<sup>bh(y<sub>1</sub>)</sup> - 1)
    + (2<sup>bh(y<sub>2</sub>)</sup> - 1) + 1

    Since bh(x) = {

        bh(y), if color(y) = red
        
        bh(y) + 1, if color(y) = black
    }
    
    size(x) >= (2<sup>bh(x) - 1</sup> - 1) + (2<sup>bh(x) - 1</sup> - 1) + 1
    = (2<sup>bh(x)</sup> - 1).

    Since every red node has black children,
    in every path from `x` to a leaf node,
    at least half the nodes are black, thus bh(x) >= h(x)/2.
    So, n = size(x) >= 2<sup>h(x)/2</sup> - 1. Therefore
    h(x) <= 2 * log<sub>2</sub>(n + 1).

    A red-black tree works as a binary-search tree for search,
    insert, etc, so the complexity of those operations is T(n) = O(h),
    that is T(n) = O(log<sub>2</sub> n), which is also the worst case complexity.

## TODO
- Override needed methods inherited from BST.

## References

- [Red-black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)

- Slides by prof. A. Carzaniga

- Chapter 13 of _Introduction to Algorithms_ (3rd ed.) by CLRS
"""

from ands.ds.BST import *
from ands.ds.RBTNode import RBTNode, RED, BLACK


__all__ = ["RBT"]


class RBT(BST):

    def __init__(self, root=None, name="RBT"):
        BST.__init__(self, root, name)

    def insert(self, x, value=None):
        """Inserts `x` into this `RBT`.

        This operation is similar to the `insert` operation of a classical `BST`,
        but, in this case, the red-black tree property must be maintained,
        so addional work is needed.    

        There are several cases of inserting into a RBT to handle:

        1. `x`  is the root node (first node).

        2. `x.parent` is `BLACK`.

        3. `x.parent` and the uncle of `x` are `RED`.

            The uncle of `x` will be the left child of `x.parent.parent`,
        if `x.parent` is the right child of `x.parent.parent`,
        otherwise (`x.parent` is the left child of `x.parent.parent`)
        the uncle will be the right child of `x.parent.parent`.

        4. x.parent is RED, but x.uncle is BLACK (or None). x.grandparent exists because x.parent is RED.

            4.1. `x` is added to the right of a left child of `x.parent.parent` (grandparent)

            4.2. or `x` is added to the left of a right child of `x.parent.parent`.

            4.3. `x` is added to the left of a left child of `x.parent.parent`.

            4.4. or `x` is added to the right of a right child of `x.parent.parent`.

        `_fix_insertion` handles these cases in the same order as just presented above.

        **Time Complexity:** O(log<sub>2</sub>(n))."""
        if x is None:
            raise ValueError("x cannot be None.")

        if not isinstance(x, RBTNode):
            x = RBTNode(x, value)

        if x.left or x.right or x.parent:
            raise ValueError("x cannot have left or right children, or parent.")

        c = self.root  # Current node
        p = None  # Current node's parent

        while c is not None:
            p = c
            if x.key < c.key:
                c = c.left
            else:  # x.key >= c.key
                c = c.right

        x.parent = p

        # The while loop was not executed even once.
        # Case 1: node is inserted as root.
        if p is None:
            self.root = x
        elif p.key > x.key:
            p.left = x
        else:  # p.key < x.key:
            p.right = x

        x.color = RED
        self.n += 1
        self._fix_insertion(x)

    def _fix_insertion(self, u: RBTNode):
        # u is the root and we color it BLACK.
        if u.parent is None:
            u.color = BLACK

        elif u.parent.color == BLACK:
            return
        
        elif u.parent.color == RED and (u.uncle is not None and u.uncle.color == RED):
            u.parent.color = BLACK
            u.uncle.color = BLACK
            u.grandparent.color = RED
            self._fix_insertion(u.grandparent)

        elif u.parent.color == RED and (u.uncle is None or u.uncle.color == BLACK):
            
            # u is added as a right child to a node that is the left child.
            if u.parent.is_left_child() and u.is_right_child():
                
                # left_rotation does not violate the property:
                # all paths from any given node to its leaf nodes
                # contain the same number of black nodes.
                self.left_rotate(u.parent)

                # With the previous left_rotate call,
                # u.parent has become the left child of u,
                # or, u bas become the parent of what before was u.parent
                # We can pass to case 5, where we have 2 red nodes in a row,
                # specifically, u.parent and u,
                # which are both left children of their parents.

                self._fix_insertion(u.left)

            # u is added as a left child to a node that is the right child.
            elif u.parent.is_right_child() and u.is_left_child():
                self.right_rotate(u.parent)
                self._fix_insertion(u.right)

            # u is added as a left child to a node that is the left child.
            elif u.parent.is_left_child() and u.is_left_child():
                # Note that grandparent is known to be black,
                # since its former child could not have been RED
                # without violating property 4.
                self.right_rotate(u.grandparent)
                u.parent.color = BLACK
                u.parent.right.color = RED

            # u is added as a right child to a node that is the right child.
            elif u.parent.is_right_child() and u.is_right_child():
                self.left_rotate(u.grandparent)
                u.parent.color = BLACK
                u.parent.left.color = RED
                
            else:
                assert False

    def delete(self, x):
        """Delete `x` from this `RBT` object.

        `x` can either be a `RBTNode` object or a key.
        
        If a key, then a search is performed first
        to find the corresponding `RBTNode` object.
        An exception is raised if a `RBTNode` object
        with a key=x is not found.
        
        If `x` is a `RBTNode` object, the only check
        that is performed is that if it hasn't a parent,
        then it must be the root. Similarly,
        a node that isn't the root must have a parent.
        If `x` has a parent, therefore it cannot be the root,
        but there's no way of knowing if this node
        really belongs to this `RBT` object,
        because no search is performed (for now).
        
        If it doesn't belong to this `RBT` object,
        then the behaviour of this method is undefined (for now).

        **Time Complexity:** O(log<sub>2</sub>(n))."""
        def delete_case1(v):
            if v.parent is not None:
                delete_case2(v)

        def delete_case2(v):
            if v.sibling.color == RED:

                assert v.parent.color == BLACK

                v.sibling.color = BLACK
                v.parent.color = RED

                if v.is_left_child():
                    self.left_rotate(v.parent)
                else:
                    self.right_rotate(v.parent)
                    
                assert v.sibling.color == BLACK

            delete_case3(v)

        def delete_case3(v):
            # not sure if the children of v.sibling can be None
            if (v.parent.color == BLACK and v.sibling.color == BLACK and
                ((v.sibling.left and v.sibling.left.color == BLACK) or not v.sibling.left) and
                ((v.sibling.right and v.sibling.right.color == BLACK) or not v.sibling.right)):

                v.sibling.color = RED
                delete_case1(v.parent)
            else:
                delete_case4(v)

        def delete_case4(v):
            # not sure if the children of v.sibling can be None
            if (v.parent.color == RED and v.sibling.color == BLACK and
                ((v.sibling.left and v.sibling.left.color == BLACK) or not v.sibling.left) and
                ((v.sibling.right and v.sibling.right.color == BLACK) or not v.sibling.right)):

                v.sibling.color = RED
                v.parent.color = BLACK
            else:
                delete_case5(v)

        def delete_case5(v):
            assert v.sibling is not None

            if v.sibling.color == BLACK:
                if (v.is_left_child() and
                    (not v.sibling.right or v.sibling.right.color == BLACK) and
                    v.sibling.left.color == RED):

                    v.sibling.color = RED
                    v.sibling.left.color = BLACK
                    self.right_rotate(v.sibling)
                    
                elif (v.is_right_child() and
                      (not v.sibling.left or v.sibling.left.color == BLACK) and
                      v.sibling.right.color == RED):

                    v.sibling.color = RED
                    v.sibling.right.color = BLACK
                    self.left_rotate(v.sibling)

            delete_case6(v)

        def delete_case6(v):
            assert v.sibling is not None

            v.sibling.color, v.parent.color = v.parent.color, v.sibling.color
            
            if v.is_left_child():
                assert v.sibling.right
                v.sibling.right.color = BLACK
                self.left_rotate(v.parent)
            else:
                assert v.sibling.left
                v.sibling.left.color = BLACK
                self.right_rotate(v.parent)
                
        if x is None:
            raise ValueError("x cannot be None.")

        if not isinstance(x, RBTNode):
            x = self.search(x)
            if x is None:
                raise LookupError("No node was found with key=x.")

        if x.parent is None and not self.is_root(x):
            raise ValueError("x is not a valid node.")

        # If x has two non-leaf children, then replace x with its successor.
        if x.left is not None and x.right is not None:
            s = self.successor(x)
            self._switch(x, s)
            x.color, s.color = s.color, x.color

        # At least one of the children must be None.
        assert x.left is None or x.right is None

        # Case 1
        # If `x` is a red node, we simply replace it with its child `c`,
        # which must be black by property 4, if any.
        # This can only occur when `x` has two leaf children,
        # because if the red node `x` had a black non-leaf child on one side,
        # but just a leaf child on the other side,
        # then the count of black nodes on both sides would be different,
        # thus the tree would violate property 5.
        # All paths through the deleted node
        # will simply pass through one fewer red node,
        # and both the deleted node's parent and child must be black,
        # so property 3 (all leaves are black) and property 4
        # (both children of every red node are black) still hold.
        if x.color == RED:
            assert x.left is None and x.right is None
            assert not self.is_root(x)

            if x.is_left_child():
                x.parent.left = None
            else:
                x.parent.right = None

        else:  # x.color == BLACK

            # One of the children of x is RED.
            # Simply removing a black node (x) could break properties 4,
            # i.e., both children of every red node are black,
            # because x.parent could be RED (e.g.), and 5,
            # i.e. all paths from any given node to its leaf nodes
            # contain the same number of black nodes),
            # but if we repaint `c` BLACK,
            # both of these properties are preserved.
            if x.left is not None and x.left.color == RED:
                if not self.is_root(x):
                    if x.is_left_child():
                        x.parent.left = x.left
                    else:
                        x.parent.right = x.left

                x.left.parent = x.parent
                x.left.color = BLACK

                if self.is_root(x):
                    self.root = x.left

            elif x.right is not None and x.right.color == RED:
                if not self.is_root(x):
                    if x.is_left_child():
                        x.parent.left = x.right
                    else:
                        x.parent.right = x.right

                x.right.parent = x.parent
                x.right.color = BLACK

                if self.is_root(x):
                    self.root = x.right

            # The complex case is when both `x` and `c` are BLACK.
            # This can only occur when deleting a black node
            # which has two leaf children, because if the black node `x`
            # had a black non-leaf child on one side
            # but just a leaf child on the other side,
            # then the count of black nodes on both sides would be different,
            # thus the tree would have been an invalid redâ€“black tree
            # by violation of property 5.
            elif x.left is None and x.right is None:
                # 6 cases
                if not self.is_root(x):
                    assert x.sibling is not None
                    
                    # Note that x.sibling cannot be None,
                    # because otherwise the substree containing it
                    # would have fewer black nodes
                    # than the subtree containing x.
                    # Specifically, the subree containing x
                    # would have a black height of 2,
                    # whereas the one containing the sibling
                    # would have a black height of 1.

                    delete_case1(x)

                    # We begin by replacing x with its child c.
                    # Note that both children of x are null-leaf children,
                    # as we observed
                    if x.is_left_child():
                        x.parent.left = None
                    else:
                        x.parent.right = None
                else:
                    self.root = None                
            else:
                assert False

        # Ensures that x has no reference to any node of this RBT.
        self.n -= 1
        x.parent = x.left = x.right = None
        return x

    def remove_max(self):
        """Removes and returns the element with the greatest value from `self`.

        **Time Complexity:** O(log<sub>2</sub>(n))."""
        if self.root:
            m = self.maximum()
            assert m
            return self.delete(m)

    def remove_min(self):
        """Removes and returns the element with the smallest value from `self`.

        **Time Complexity:** O(log<sub>2</sub>(n))."""        
        if self.root:
            m = self.minimum()
            assert m
            return self.delete(m)
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="ands.ds.RBT.RBT" class="name">class <span class="ident">RBT</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT" class="source">
    <pre><code>class RBT(BST):

    def __init__(self, root=None, name="RBT"):
        BST.__init__(self, root, name)

    def insert(self, x, value=None):
        """Inserts `x` into this `RBT`.

        This operation is similar to the `insert` operation of a classical `BST`,
        but, in this case, the red-black tree property must be maintained,
        so addional work is needed.    

        There are several cases of inserting into a RBT to handle:

        1. `x`  is the root node (first node).

        2. `x.parent` is `BLACK`.

        3. `x.parent` and the uncle of `x` are `RED`.

            The uncle of `x` will be the left child of `x.parent.parent`,
        if `x.parent` is the right child of `x.parent.parent`,
        otherwise (`x.parent` is the left child of `x.parent.parent`)
        the uncle will be the right child of `x.parent.parent`.

        4. x.parent is RED, but x.uncle is BLACK (or None). x.grandparent exists because x.parent is RED.

            4.1. `x` is added to the right of a left child of `x.parent.parent` (grandparent)

            4.2. or `x` is added to the left of a right child of `x.parent.parent`.

            4.3. `x` is added to the left of a left child of `x.parent.parent`.

            4.4. or `x` is added to the right of a right child of `x.parent.parent`.

        `_fix_insertion` handles these cases in the same order as just presented above.

        **Time Complexity:** O(log<sub>2</sub>(n))."""
        if x is None:
            raise ValueError("x cannot be None.")

        if not isinstance(x, RBTNode):
            x = RBTNode(x, value)

        if x.left or x.right or x.parent:
            raise ValueError("x cannot have left or right children, or parent.")

        c = self.root  # Current node
        p = None  # Current node's parent

        while c is not None:
            p = c
            if x.key < c.key:
                c = c.left
            else:  # x.key >= c.key
                c = c.right

        x.parent = p

        # The while loop was not executed even once.
        # Case 1: node is inserted as root.
        if p is None:
            self.root = x
        elif p.key > x.key:
            p.left = x
        else:  # p.key < x.key:
            p.right = x

        x.color = RED
        self.n += 1
        self._fix_insertion(x)

    def _fix_insertion(self, u: RBTNode):
        # u is the root and we color it BLACK.
        if u.parent is None:
            u.color = BLACK

        elif u.parent.color == BLACK:
            return
        
        elif u.parent.color == RED and (u.uncle is not None and u.uncle.color == RED):
            u.parent.color = BLACK
            u.uncle.color = BLACK
            u.grandparent.color = RED
            self._fix_insertion(u.grandparent)

        elif u.parent.color == RED and (u.uncle is None or u.uncle.color == BLACK):
            
            # u is added as a right child to a node that is the left child.
            if u.parent.is_left_child() and u.is_right_child():
                
                # left_rotation does not violate the property:
                # all paths from any given node to its leaf nodes
                # contain the same number of black nodes.
                self.left_rotate(u.parent)

                # With the previous left_rotate call,
                # u.parent has become the left child of u,
                # or, u bas become the parent of what before was u.parent
                # We can pass to case 5, where we have 2 red nodes in a row,
                # specifically, u.parent and u,
                # which are both left children of their parents.

                self._fix_insertion(u.left)

            # u is added as a left child to a node that is the right child.
            elif u.parent.is_right_child() and u.is_left_child():
                self.right_rotate(u.parent)
                self._fix_insertion(u.right)

            # u is added as a left child to a node that is the left child.
            elif u.parent.is_left_child() and u.is_left_child():
                # Note that grandparent is known to be black,
                # since its former child could not have been RED
                # without violating property 4.
                self.right_rotate(u.grandparent)
                u.parent.color = BLACK
                u.parent.right.color = RED

            # u is added as a right child to a node that is the right child.
            elif u.parent.is_right_child() and u.is_right_child():
                self.left_rotate(u.grandparent)
                u.parent.color = BLACK
                u.parent.left.color = RED
                
            else:
                assert False

    def delete(self, x):
        """Delete `x` from this `RBT` object.

        `x` can either be a `RBTNode` object or a key.
        
        If a key, then a search is performed first
        to find the corresponding `RBTNode` object.
        An exception is raised if a `RBTNode` object
        with a key=x is not found.
        
        If `x` is a `RBTNode` object, the only check
        that is performed is that if it hasn't a parent,
        then it must be the root. Similarly,
        a node that isn't the root must have a parent.
        If `x` has a parent, therefore it cannot be the root,
        but there's no way of knowing if this node
        really belongs to this `RBT` object,
        because no search is performed (for now).
        
        If it doesn't belong to this `RBT` object,
        then the behaviour of this method is undefined (for now).

        **Time Complexity:** O(log<sub>2</sub>(n))."""
        def delete_case1(v):
            if v.parent is not None:
                delete_case2(v)

        def delete_case2(v):
            if v.sibling.color == RED:

                assert v.parent.color == BLACK

                v.sibling.color = BLACK
                v.parent.color = RED

                if v.is_left_child():
                    self.left_rotate(v.parent)
                else:
                    self.right_rotate(v.parent)
                    
                assert v.sibling.color == BLACK

            delete_case3(v)

        def delete_case3(v):
            # not sure if the children of v.sibling can be None
            if (v.parent.color == BLACK and v.sibling.color == BLACK and
                ((v.sibling.left and v.sibling.left.color == BLACK) or not v.sibling.left) and
                ((v.sibling.right and v.sibling.right.color == BLACK) or not v.sibling.right)):

                v.sibling.color = RED
                delete_case1(v.parent)
            else:
                delete_case4(v)

        def delete_case4(v):
            # not sure if the children of v.sibling can be None
            if (v.parent.color == RED and v.sibling.color == BLACK and
                ((v.sibling.left and v.sibling.left.color == BLACK) or not v.sibling.left) and
                ((v.sibling.right and v.sibling.right.color == BLACK) or not v.sibling.right)):

                v.sibling.color = RED
                v.parent.color = BLACK
            else:
                delete_case5(v)

        def delete_case5(v):
            assert v.sibling is not None

            if v.sibling.color == BLACK:
                if (v.is_left_child() and
                    (not v.sibling.right or v.sibling.right.color == BLACK) and
                    v.sibling.left.color == RED):

                    v.sibling.color = RED
                    v.sibling.left.color = BLACK
                    self.right_rotate(v.sibling)
                    
                elif (v.is_right_child() and
                      (not v.sibling.left or v.sibling.left.color == BLACK) and
                      v.sibling.right.color == RED):

                    v.sibling.color = RED
                    v.sibling.right.color = BLACK
                    self.left_rotate(v.sibling)

            delete_case6(v)

        def delete_case6(v):
            assert v.sibling is not None

            v.sibling.color, v.parent.color = v.parent.color, v.sibling.color
            
            if v.is_left_child():
                assert v.sibling.right
                v.sibling.right.color = BLACK
                self.left_rotate(v.parent)
            else:
                assert v.sibling.left
                v.sibling.left.color = BLACK
                self.right_rotate(v.parent)
                
        if x is None:
            raise ValueError("x cannot be None.")

        if not isinstance(x, RBTNode):
            x = self.search(x)
            if x is None:
                raise LookupError("No node was found with key=x.")

        if x.parent is None and not self.is_root(x):
            raise ValueError("x is not a valid node.")

        # If x has two non-leaf children, then replace x with its successor.
        if x.left is not None and x.right is not None:
            s = self.successor(x)
            self._switch(x, s)
            x.color, s.color = s.color, x.color

        # At least one of the children must be None.
        assert x.left is None or x.right is None

        # Case 1
        # If `x` is a red node, we simply replace it with its child `c`,
        # which must be black by property 4, if any.
        # This can only occur when `x` has two leaf children,
        # because if the red node `x` had a black non-leaf child on one side,
        # but just a leaf child on the other side,
        # then the count of black nodes on both sides would be different,
        # thus the tree would violate property 5.
        # All paths through the deleted node
        # will simply pass through one fewer red node,
        # and both the deleted node's parent and child must be black,
        # so property 3 (all leaves are black) and property 4
        # (both children of every red node are black) still hold.
        if x.color == RED:
            assert x.left is None and x.right is None
            assert not self.is_root(x)

            if x.is_left_child():
                x.parent.left = None
            else:
                x.parent.right = None

        else:  # x.color == BLACK

            # One of the children of x is RED.
            # Simply removing a black node (x) could break properties 4,
            # i.e., both children of every red node are black,
            # because x.parent could be RED (e.g.), and 5,
            # i.e. all paths from any given node to its leaf nodes
            # contain the same number of black nodes),
            # but if we repaint `c` BLACK,
            # both of these properties are preserved.
            if x.left is not None and x.left.color == RED:
                if not self.is_root(x):
                    if x.is_left_child():
                        x.parent.left = x.left
                    else:
                        x.parent.right = x.left

                x.left.parent = x.parent
                x.left.color = BLACK

                if self.is_root(x):
                    self.root = x.left

            elif x.right is not None and x.right.color == RED:
                if not self.is_root(x):
                    if x.is_left_child():
                        x.parent.left = x.right
                    else:
                        x.parent.right = x.right

                x.right.parent = x.parent
                x.right.color = BLACK

                if self.is_root(x):
                    self.root = x.right

            # The complex case is when both `x` and `c` are BLACK.
            # This can only occur when deleting a black node
            # which has two leaf children, because if the black node `x`
            # had a black non-leaf child on one side
            # but just a leaf child on the other side,
            # then the count of black nodes on both sides would be different,
            # thus the tree would have been an invalid redâ€“black tree
            # by violation of property 5.
            elif x.left is None and x.right is None:
                # 6 cases
                if not self.is_root(x):
                    assert x.sibling is not None
                    
                    # Note that x.sibling cannot be None,
                    # because otherwise the substree containing it
                    # would have fewer black nodes
                    # than the subtree containing x.
                    # Specifically, the subree containing x
                    # would have a black height of 2,
                    # whereas the one containing the sibling
                    # would have a black height of 1.

                    delete_case1(x)

                    # We begin by replacing x with its child c.
                    # Note that both children of x are null-leaf children,
                    # as we observed
                    if x.is_left_child():
                        x.parent.left = None
                    else:
                        x.parent.right = None
                else:
                    self.root = None                
            else:
                assert False

        # Ensures that x has no reference to any node of this RBT.
        self.n -= 1
        x.parent = x.left = x.right = None
        return x

    def remove_max(self):
        """Removes and returns the element with the greatest value from `self`.

        **Time Complexity:** O(log<sub>2</sub>(n))."""
        if self.root:
            m = self.maximum()
            assert m
            return self.delete(m)

    def remove_min(self):
        """Removes and returns the element with the smallest value from `self`.

        **Time Complexity:** O(log<sub>2</sub>(n))."""        
        if self.root:
            m = self.minimum()
            assert m
            return self.delete(m)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ands.ds.RBT.RBT">RBT</a></li>
          <li>ands.ds.BST.BST</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, root=None, name=&#39;RBT&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.__init__" class="source">
    <pre><code>def __init__(self, root=None, name="RBT"):
    BST.__init__(self, root, name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.clear">
    <p>def <span class="ident">clear</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Removes all nodes from this tree.</p>
<p><strong>Time Complexity</strong>: O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.clear', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.clear" class="source">
    <pre><code>def clear(self):
    """Removes all nodes from this tree.
    **Time Complexity**: O(1)."""
    self.root = None
    self.n = 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.contains">
    <p>def <span class="ident">contains</span>(</p><p>self, key)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if a <code>BSTNode</code> object with <code>key</code> exists in the tree.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.contains', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.contains" class="source">
    <pre><code>def contains(self, key) -> bool:
    """Returns `True` if a `BSTNode` object with `key` exists in the tree.
    **Time Complexity**: O(h)."""
    return self.search_r(key) is not None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.delete">
    <p>def <span class="ident">delete</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete <code>x</code> from this <code>RBT</code> object.</p>
<p><code>x</code> can either be a <code>RBTNode</code> object or a key.</p>
<p>If a key, then a search is performed first
to find the corresponding <code>RBTNode</code> object.
An exception is raised if a <code>RBTNode</code> object
with a key=x is not found.</p>
<p>If <code>x</code> is a <code>RBTNode</code> object, the only check
that is performed is that if it hasn't a parent,
then it must be the root. Similarly,
a node that isn't the root must have a parent.
If <code>x</code> has a parent, therefore it cannot be the root,
but there's no way of knowing if this node
really belongs to this <code>RBT</code> object,
because no search is performed (for now).</p>
<p>If it doesn't belong to this <code>RBT</code> object,
then the behaviour of this method is undefined (for now).</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub>(n)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.delete', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.delete" class="source">
    <pre><code>def delete(self, x):
    """Delete `x` from this `RBT` object.
    `x` can either be a `RBTNode` object or a key.
    
    If a key, then a search is performed first
    to find the corresponding `RBTNode` object.
    An exception is raised if a `RBTNode` object
    with a key=x is not found.
    
    If `x` is a `RBTNode` object, the only check
    that is performed is that if it hasn't a parent,
    then it must be the root. Similarly,
    a node that isn't the root must have a parent.
    If `x` has a parent, therefore it cannot be the root,
    but there's no way of knowing if this node
    really belongs to this `RBT` object,
    because no search is performed (for now).
    
    If it doesn't belong to this `RBT` object,
    then the behaviour of this method is undefined (for now).
    **Time Complexity:** O(log<sub>2</sub>(n))."""
    def delete_case1(v):
        if v.parent is not None:
            delete_case2(v)
    def delete_case2(v):
        if v.sibling.color == RED:
            assert v.parent.color == BLACK
            v.sibling.color = BLACK
            v.parent.color = RED
            if v.is_left_child():
                self.left_rotate(v.parent)
            else:
                self.right_rotate(v.parent)
                
            assert v.sibling.color == BLACK
        delete_case3(v)
    def delete_case3(v):
        # not sure if the children of v.sibling can be None
        if (v.parent.color == BLACK and v.sibling.color == BLACK and
            ((v.sibling.left and v.sibling.left.color == BLACK) or not v.sibling.left) and
            ((v.sibling.right and v.sibling.right.color == BLACK) or not v.sibling.right)):
            v.sibling.color = RED
            delete_case1(v.parent)
        else:
            delete_case4(v)
    def delete_case4(v):
        # not sure if the children of v.sibling can be None
        if (v.parent.color == RED and v.sibling.color == BLACK and
            ((v.sibling.left and v.sibling.left.color == BLACK) or not v.sibling.left) and
            ((v.sibling.right and v.sibling.right.color == BLACK) or not v.sibling.right)):
            v.sibling.color = RED
            v.parent.color = BLACK
        else:
            delete_case5(v)
    def delete_case5(v):
        assert v.sibling is not None
        if v.sibling.color == BLACK:
            if (v.is_left_child() and
                (not v.sibling.right or v.sibling.right.color == BLACK) and
                v.sibling.left.color == RED):
                v.sibling.color = RED
                v.sibling.left.color = BLACK
                self.right_rotate(v.sibling)
                
            elif (v.is_right_child() and
                  (not v.sibling.left or v.sibling.left.color == BLACK) and
                  v.sibling.right.color == RED):
                v.sibling.color = RED
                v.sibling.right.color = BLACK
                self.left_rotate(v.sibling)
        delete_case6(v)
    def delete_case6(v):
        assert v.sibling is not None
        v.sibling.color, v.parent.color = v.parent.color, v.sibling.color
        
        if v.is_left_child():
            assert v.sibling.right
            v.sibling.right.color = BLACK
            self.left_rotate(v.parent)
        else:
            assert v.sibling.left
            v.sibling.left.color = BLACK
            self.right_rotate(v.parent)
            
    if x is None:
        raise ValueError("x cannot be None.")
    if not isinstance(x, RBTNode):
        x = self.search(x)
        if x is None:
            raise LookupError("No node was found with key=x.")
    if x.parent is None and not self.is_root(x):
        raise ValueError("x is not a valid node.")
    # If x has two non-leaf children, then replace x with its successor.
    if x.left is not None and x.right is not None:
        s = self.successor(x)
        self._switch(x, s)
        x.color, s.color = s.color, x.color
    # At least one of the children must be None.
    assert x.left is None or x.right is None
    # Case 1
    # If `x` is a red node, we simply replace it with its child `c`,
    # which must be black by property 4, if any.
    # This can only occur when `x` has two leaf children,
    # because if the red node `x` had a black non-leaf child on one side,
    # but just a leaf child on the other side,
    # then the count of black nodes on both sides would be different,
    # thus the tree would violate property 5.
    # All paths through the deleted node
    # will simply pass through one fewer red node,
    # and both the deleted node's parent and child must be black,
    # so property 3 (all leaves are black) and property 4
    # (both children of every red node are black) still hold.
    if x.color == RED:
        assert x.left is None and x.right is None
        assert not self.is_root(x)
        if x.is_left_child():
            x.parent.left = None
        else:
            x.parent.right = None
    else:  # x.color == BLACK
        # One of the children of x is RED.
        # Simply removing a black node (x) could break properties 4,
        # i.e., both children of every red node are black,
        # because x.parent could be RED (e.g.), and 5,
        # i.e. all paths from any given node to its leaf nodes
        # contain the same number of black nodes),
        # but if we repaint `c` BLACK,
        # both of these properties are preserved.
        if x.left is not None and x.left.color == RED:
            if not self.is_root(x):
                if x.is_left_child():
                    x.parent.left = x.left
                else:
                    x.parent.right = x.left
            x.left.parent = x.parent
            x.left.color = BLACK
            if self.is_root(x):
                self.root = x.left
        elif x.right is not None and x.right.color == RED:
            if not self.is_root(x):
                if x.is_left_child():
                    x.parent.left = x.right
                else:
                    x.parent.right = x.right
            x.right.parent = x.parent
            x.right.color = BLACK
            if self.is_root(x):
                self.root = x.right
        # The complex case is when both `x` and `c` are BLACK.
        # This can only occur when deleting a black node
        # which has two leaf children, because if the black node `x`
        # had a black non-leaf child on one side
        # but just a leaf child on the other side,
        # then the count of black nodes on both sides would be different,
        # thus the tree would have been an invalid redâ€“black tree
        # by violation of property 5.
        elif x.left is None and x.right is None:
            # 6 cases
            if not self.is_root(x):
                assert x.sibling is not None
                
                # Note that x.sibling cannot be None,
                # because otherwise the substree containing it
                # would have fewer black nodes
                # than the subtree containing x.
                # Specifically, the subree containing x
                # would have a black height of 2,
                # whereas the one containing the sibling
                # would have a black height of 1.
                delete_case1(x)
                # We begin by replacing x with its child c.
                # Note that both children of x are null-leaf children,
                # as we observed
                if x.is_left_child():
                    x.parent.left = None
                else:
                    x.parent.right = None
            else:
                self.root = None                
        else:
            assert False
    # Ensures that x has no reference to any node of this RBT.
    self.n -= 1
    x.parent = x.left = x.right = None
    return x
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.height">
    <p>def <span class="ident">height</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the maximum depth or height of the tree.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.height', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.height" class="source">
    <pre><code>def height(self) -> int:
    """Returns the maximum depth or height of the tree.
    **Time Complexity**: O(h)."""
    if self.root is None:
        return 0
    return self._height(self.root)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.in_order_traversal">
    <p>def <span class="ident">in_order_traversal</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Prints the elements of the tree in increasing order.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.in_order_traversal', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.in_order_traversal" class="source">
    <pre><code>def in_order_traversal(self):
    """Prints the elements of the tree in increasing order.
    **Time Complexity**: O(h)."""
    self._in_order_traversal(self.root)
    print("\n")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.insert">
    <p>def <span class="ident">insert</span>(</p><p>self, x, value=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Inserts <code>x</code> into this <code>RBT</code>.</p>
<p>This operation is similar to the <code>insert</code> operation of a classical <code>BST</code>,
but, in this case, the red-black tree property must be maintained,
so addional work is needed.    </p>
<p>There are several cases of inserting into a RBT to handle:</p>
<ol>
<li>
<p><code>x</code>  is the root node (first node).</p>
</li>
<li>
<p><code>x.parent</code> is <code>BLACK</code>.</p>
</li>
<li>
<p><code>x.parent</code> and the uncle of <code>x</code> are <code>RED</code>.</p>
<p>The uncle of <code>x</code> will be the left child of <code>x.parent.parent</code>,
if <code>x.parent</code> is the right child of <code>x.parent.parent</code>,
otherwise (<code>x.parent</code> is the left child of <code>x.parent.parent</code>)
the uncle will be the right child of <code>x.parent.parent</code>.</p>
</li>
<li>
<p>x.parent is RED, but x.uncle is BLACK (or None). x.grandparent exists because x.parent is RED.</p>
<p>4.1. <code>x</code> is added to the right of a left child of <code>x.parent.parent</code> (grandparent)</p>
<p>4.2. or <code>x</code> is added to the left of a right child of <code>x.parent.parent</code>.</p>
<p>4.3. <code>x</code> is added to the left of a left child of <code>x.parent.parent</code>.</p>
<p>4.4. or <code>x</code> is added to the right of a right child of <code>x.parent.parent</code>.</p>
</li>
</ol>
<p><code>_fix_insertion</code> handles these cases in the same order as just presented above.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub>(n)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.insert', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.insert" class="source">
    <pre><code>def insert(self, x, value=None):
    """Inserts `x` into this `RBT`.
    This operation is similar to the `insert` operation of a classical `BST`,
    but, in this case, the red-black tree property must be maintained,
    so addional work is needed.    
    There are several cases of inserting into a RBT to handle:
    1. `x`  is the root node (first node).
    2. `x.parent` is `BLACK`.
    3. `x.parent` and the uncle of `x` are `RED`.
        The uncle of `x` will be the left child of `x.parent.parent`,
    if `x.parent` is the right child of `x.parent.parent`,
    otherwise (`x.parent` is the left child of `x.parent.parent`)
    the uncle will be the right child of `x.parent.parent`.
    4. x.parent is RED, but x.uncle is BLACK (or None). x.grandparent exists because x.parent is RED.
        4.1. `x` is added to the right of a left child of `x.parent.parent` (grandparent)
        4.2. or `x` is added to the left of a right child of `x.parent.parent`.
        4.3. `x` is added to the left of a left child of `x.parent.parent`.
        4.4. or `x` is added to the right of a right child of `x.parent.parent`.
    `_fix_insertion` handles these cases in the same order as just presented above.
    **Time Complexity:** O(log<sub>2</sub>(n))."""
    if x is None:
        raise ValueError("x cannot be None.")
    if not isinstance(x, RBTNode):
        x = RBTNode(x, value)
    if x.left or x.right or x.parent:
        raise ValueError("x cannot have left or right children, or parent.")
    c = self.root  # Current node
    p = None  # Current node's parent
    while c is not None:
        p = c
        if x.key < c.key:
            c = c.left
        else:  # x.key >= c.key
            c = c.right
    x.parent = p
    # The while loop was not executed even once.
    # Case 1: node is inserted as root.
    if p is None:
        self.root = x
    elif p.key > x.key:
        p.left = x
    else:  # p.key < x.key:
        p.right = x
    x.color = RED
    self.n += 1
    self._fix_insertion(x)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.insert_many">
    <p>def <span class="ident">insert_many</span>(</p><p>self, ls)</p>
    </div>
    

    
  
    <div class="desc"><p>Calls <code>self.insert</code> for all elements of <code>ls</code>.
Therefore the elements of <code>ls</code> should either be
<code>BSTNode</code> objects or they should represent keys.</p>
<p><strong>Time Complexity</strong>: O(len(ls)*h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.insert_many', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.insert_many" class="source">
    <pre><code>def insert_many(self, ls):
    """Calls `self.insert` for all elements of `ls`.
    Therefore the elements of `ls` should either be
    `BSTNode` objects or they should represent keys.
    **Time Complexity**: O(len(ls)*h)."""
    for i in ls:
        self.insert(i)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.is_empty">
    <p>def <span class="ident">is_empty</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if this tree has 0 nodes.</p>
<p><strong>Time Complexity</strong>: O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.is_empty', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.is_empty" class="source">
    <pre><code>def is_empty(self):
    """Returns `True` if this tree has 0 nodes.
    **Time Complexity**: O(1)."""
    return self.size() == 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.is_root">
    <p>def <span class="ident">is_root</span>(</p><p>self, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks if <code>u</code> is the root.</p>
<p><strong>Time Complexity</strong>: O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.is_root', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.is_root" class="source">
    <pre><code>def is_root(self, u: BSTNode):
    """Checks if `u` is the root.
    **Time Complexity**: O(1)."""
    if u == self.root:            
        assert u.parent is None
    return u == self.root
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.left_rotate">
    <p>def <span class="ident">left_rotate</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Left rotates the subtree rooted at node <code>x</code>.</p>
<p><code>x</code> can be a <code>BSTNode</code> object, and in that case,
this function performs in constant time O(1);
else, if node is not a <code>BSTNode</code> object,
it tries to search for a <code>BSTNode</code> object with key=x,
and, in that case, it performs in O(h) time.</p>
<p>Returns the node which is at the previous position of <code>x</code>,
that is it returns the parent of <code>x</code>.</p>
<p><strong>Time Complexity</strong>: O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.left_rotate', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.left_rotate" class="source">
    <pre><code>def left_rotate(self, x):
    """Left rotates the subtree rooted at node `x`.
    `x` can be a `BSTNode` object, and in that case,
    this function performs in constant time O(1);
    else, if node is not a `BSTNode` object,
    it tries to search for a `BSTNode` object with key=x,
    and, in that case, it performs in O(h) time.
    Returns the node which is at the previous position of `x`,
    that is it returns the parent of `x`.
    **Time Complexity**: O(1)."""
    c = None  # It will rotate the subtree rooted at c.
    if not isinstance(x, BSTNode):
        c = self.search(x)
        if c is None:
            raise LookupError("key node was not found in the tree.")
    else:
        c = x
    
    # To left rotate a node, its right child must exist.
    if c.right is None:
        raise ValueError("Left rotation cannot be performed on " + str(c) +
                        " because it does not have a right child.")
    c.right.parent = c.parent
    # Only the root has a None parent.
    if c.parent is None:
        self.root = c.right
        
    # Checking if c is a left or a right child,
    # in order to set the new left
    # or right child respectively of its parent.
    elif c.is_left_child():
        c.parent.left = c.right
    else:
        c.parent.right = c.right
    c.parent = c.right
    # The new right child of c becomes what is
    # the left child of its previous right child.
    c.right = c.parent.left
    # Set c to be the parent of its new right child.
    if c.right is not None:
        c.right.parent = c
    # Set c to be the new left child of its new parent.
    c.parent.left = c
    return c.parent
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.maximum">
    <p>def <span class="ident">maximum</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Calls <code>BST._maximum_r(self.root)</code> if <code>self.root</code> is evaluated to <code>True</code>.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.maximum', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.maximum" class="source">
    <pre><code>def maximum(self):
    """Calls `BST._maximum_r(self.root)` if `self.root` is evaluated to `True`.
    **Time Complexity**: O(h)."""
    if self.root:
        return BST._maximum_r(self.root)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.minimum">
    <p>def <span class="ident">minimum</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Calls <code>BST._minimum_r(self.root)</code> if <code>self.root</code> is evaluated to <code>True</code>.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.minimum', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.minimum" class="source">
    <pre><code>def minimum(self):
    """Calls `BST._minimum_r(self.root)` if `self.root` is evaluated to `True`.
    **Time Complexity**: O(h)."""
    if self.root:
        return BST._minimum_r(self.root)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.post_order_traversal">
    <p>def <span class="ident">post_order_traversal</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Prints the keys of this tree in post-order.
It does the opposite of <code>pre_order_traversal</code>.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.post_order_traversal', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.post_order_traversal" class="source">
    <pre><code>def post_order_traversal(self):
    """Prints the keys of this tree in post-order.
    It does the opposite of `pre_order_traversal`.
    
    **Time Complexity**: O(h)."""
    self._post_order_traversal(self.root)
    print("\n")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.pre_order_traversal">
    <p>def <span class="ident">pre_order_traversal</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Prints the keys of this tree in pre-order.
The pre-order consists of recursively printing first a node <code>u</code>,
then its left child node and then its right child node.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.pre_order_traversal', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.pre_order_traversal" class="source">
    <pre><code>def pre_order_traversal(self):
    """Prints the keys of this tree in pre-order.
    The pre-order consists of recursively printing first a node `u`,
    then its left child node and then its right child node.
    **Time Complexity**: O(h)."""
    self._pre_order_traversal(self.root)
    print("\n")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.predecessor">
    <p>def <span class="ident">predecessor</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Finds the predecessor of the node <code>x</code>,
i.e. the greatest element smaller than <code>x</code>.</p>
<p><code>x</code> can either be a reference to an actual <code>BSTNode</code> object,
or it can be a key of a supposed node in self.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.predecessor', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.predecessor" class="source">
    <pre><code>def predecessor(self, x):
    """Finds the predecessor of the node `x`,
    i.e. the greatest element smaller than `x`.
    
    `x` can either be a reference to an actual `BSTNode` object,
    or it can be a key of a supposed node in self.
    **Time Complexity**: O(h)."""
    if not isinstance(x, BSTNode):
        x = self.search_r(x)
        if x is None:
            raise LookupError("No node was found with key=x.")
    if x.left:
        return BST._maximum_r(x.left)
    p = x.parent
    while p and x == p.left:
        x = p
        p = x.parent
    return p
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.rank">
    <p>def <span class="ident">rank</span>(</p><p>self, key)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the number of keys strictly less than <code>key</code>.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.rank', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.rank" class="source">
    <pre><code>def rank(self, key) -> int:
    """Returns the number of keys strictly less than `key`.
    **Time Complexity**: O(h)."""
    if key is None:
        raise ValueError("key cannot be None.")
    if not self.search(key):
        raise LookupError("key was not found.")
    if self.root is None:
        return 0
    else:
        r = 0
        return self._rank(self.root, key, r)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.remove_max">
    <p>def <span class="ident">remove_max</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Removes and returns the element with the greatest value from <code>self</code>.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub>(n)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.remove_max', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.remove_max" class="source">
    <pre><code>def remove_max(self):
    """Removes and returns the element with the greatest value from `self`.
    **Time Complexity:** O(log<sub>2</sub>(n))."""
    if self.root:
        m = self.maximum()
        assert m
        return self.delete(m)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.remove_min">
    <p>def <span class="ident">remove_min</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Removes and returns the element with the smallest value from <code>self</code>.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub>(n)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.remove_min', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.remove_min" class="source">
    <pre><code>def remove_min(self):
    """Removes and returns the element with the smallest value from `self`.
    **Time Complexity:** O(log<sub>2</sub>(n))."""        
    if self.root:
        m = self.minimum()
        assert m
        return self.delete(m)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.reverse_in_order_traversal">
    <p>def <span class="ident">reverse_in_order_traversal</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Prints the keys of this tree in decreasing order.</p>
<p>It does the opposite of <code>self.in_order_traversal</code>.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.reverse_in_order_traversal', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.reverse_in_order_traversal" class="source">
    <pre><code>def reverse_in_order_traversal(self):
    """Prints the keys of this tree in decreasing order.
    It does the opposite of `self.in_order_traversal`.
    **Time Complexity**: O(h)."""
    self._reverse_in_order_traversal(self.root)
    print("\n")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.right_rotate">
    <p>def <span class="ident">right_rotate</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Right rotates the subtree rooted at node <code>x</code>.
See doc-strings of <code>self.left_rotate</code>.</p>
<p><strong>Time Complexity</strong>: O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.right_rotate', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.right_rotate" class="source">
    <pre><code>def right_rotate(self, x):
    """Right rotates the subtree rooted at node `x`.
    See doc-strings of `self.left_rotate`.
    **Time Complexity**: O(1)."""
    c = None
    if not isinstance(x, BSTNode):
        c = self.search(x)
        if c is None:
            raise LookupError("key node was not found in the tree.")
    else:
        c = x
    if c.left is None:
        raise ValueError("Right rotation cannot be performed on " + str(c) +
                        " because it does not have a left child.")
    c.left.parent = c.parent
    if c.parent is None:
        self.root = c.left
    elif c.is_left_child():
        c.parent.left = c.left
    else:
        c.parent.right = c.left
    c.parent = c.left
    c.left = c.parent.right
    if c.left is not None:
        c.left.parent = c
    c.parent.right = c
    return c.parent
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.search">
    <p>def <span class="ident">search</span>(</p><p>self, key, s=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Searches for the key in the tree.
If <code>s</code> is specified, then this procedure starts searching from <code>s</code>.</p>
<p><code>key</code> must be a comparable object of the same type as the other keys.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.search', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.search" class="source">
    <pre><code>def search(self, key, s: BSTNode=None) -> BSTNode:
    """Searches for the key in the tree.
    If `s` is specified, then this procedure starts searching from `s`.
    `key` must be a comparable object of the same type as the other keys.
    **Time Complexity**: O(h)."""
    if key is None:
        raise ValueError("key cannot be None.")
    if s is None:
        return self.search_i(key)
    else:
        return BST._search_i(key, s)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.search_i">
    <p>def <span class="ident">search_i</span>(</p><p>self, key)</p>
    </div>
    

    
  
    <div class="desc"><p>Searches iteratively for key starting from the root.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.search_i', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.search_i" class="source">
    <pre><code>def search_i(self, key) -> BSTNode:
    """Searches iteratively for key starting from the root.
    **Time Complexity**: O(h)."""
    return BST._search_i(key, self.root)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.search_r">
    <p>def <span class="ident">search_r</span>(</p><p>self, key)</p>
    </div>
    

    
  
    <div class="desc"><p>Searches recursively for <code>key</code> starting from <code>self.root</code>.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.search_r', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.search_r" class="source">
    <pre><code>def search_r(self, key) -> BSTNode:
    """Searches recursively for `key` starting from `self.root`.
    
    **Time Complexity**: O(h)."""
    return self._search_r(key, self.root)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.show">
    <p>def <span class="ident">show</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Pretty-prints this tree using <code>print</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.show', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.show" class="source">
    <pre><code>def show(self):
    """Pretty-prints this tree using `print`."""
    print(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.size">
    <p>def <span class="ident">size</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the total number of nodes.</p>
<p><strong>Time Complexity</strong>: O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.size', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.size" class="source">
    <pre><code>def size(self):
    """Returns the total number of nodes.
    **Time Complexity**: O(1)."""
    return self.n
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.RBT.RBT.successor">
    <p>def <span class="ident">successor</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Finds the successor of <code>x</code>,
i.e. the smallest element greater than <code>x</code>.</p>
<p>If <code>x</code> has a right subtree,
then the successor of <code>x</code> is the minimum of that right subtree.</p>
<p>Otherwise it is the first ancestor of <code>x</code>, lets call it <code>A</code>, 
such that <code>x</code> falls in the left subtree of <code>A</code>.</p>
<p><code>x</code> can either be a reference to an actual <code>BSTNode</code> object,
or it can be a key of a supposed node in self.</p>
<p><strong>Time Complexity</strong>: O(h).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.RBT.RBT.successor', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.RBT.RBT.successor" class="source">
    <pre><code>def successor(self, x):
    """Finds the successor of `x`,
    i.e. the smallest element greater than `x`.
    
    If `x` has a right subtree,
    then the successor of `x` is the minimum of that right subtree.
    Otherwise it is the first ancestor of `x`, lets call it `A`, 
    such that `x` falls in the left subtree of `A`.
    `x` can either be a reference to an actual `BSTNode` object,
    or it can be a key of a supposed node in self.
    **Time Complexity**: O(h)."""
    if not isinstance(x, BSTNode):
        x = self.search(x)
        if not x:
            raise LookupError("No node was found with key=x.")
    if x.right:
        return BST._minimum_r(x.right)
    p = x.parent
    while p and p.right == x:
        x = p
        p = x.parent
    return p
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
